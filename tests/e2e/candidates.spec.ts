/**
 * E2E Tests for Candidate Numbers Feature
 *
 * Tests candidate number functionality per T089 in tasks.md.
 * Focuses on basic functionality that is currently implemented.
 */

import { test, expect } from '@playwright/test';
import { startNewGameIfNeeded } from './helpers';

test.describe('Candidate Numbers Feature', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await startNewGameIfNeeded(page);
  });

  test('should toggle auto-candidates display', async ({ page }) => {
    // Find the Fill Candidates button
    const fillCandidatesButton = page.getByRole('button', { name: /Fill Candidates/i });

    // Scroll the button into view if needed
    await fillCandidatesButton.scrollIntoViewIfNeeded();
    await expect(fillCandidatesButton).toBeVisible();

    // Click the button to populate candidates
    await fillCandidatesButton.click();

    // Wait for candidates to be generated by checking for a candidate element
    await page.locator('.candidate-number:not(.empty)').first().waitFor({ state: 'visible', timeout: 5000 });

    // Find an empty cell (non-clue cell with no value but with candidates)
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let emptyCellFound = false;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        // This is an empty cell, check for candidates
        const candidates = cell.locator('.candidate-number:not(.empty)');
        const candidateCount = await candidates.count();

        if (candidateCount > 0) {
          await expect(candidates.first()).toBeVisible();
          emptyCellFound = true;
          break;
        }
      }
    }

    expect(emptyCellFound).toBe(true);
  });

  test('should handle cell selection and normal number entry', async ({ page }) => {
    // Find the first non-clue cell
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let targetCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));

      if (!hasClueClass) {
        targetCell = cell;
        break;
      }
    }

    if (!targetCell) {
      throw new Error('No editable cell found');
    }

    await targetCell.click();

    // Cell should be selected (wrapper should have selected class)
    await targetCell.getAttribute('data-row');
    await targetCell.getAttribute('data-col');
    const cellWrapper = page.locator(`.cell-wrapper[class*="selected"]`).first();
    await expect(cellWrapper).toBeVisible();

    // Enter a number
    await page.keyboard.press('5');

    // Cell should now show the number
    await expect(targetCell).toContainText('5');

    // Candidates should not be visible in a filled cell
    const candidates = targetCell.locator('.candidate-number');
    await expect(candidates).toHaveCount(0);
  });

  test('should navigate between cells correctly', async ({ page }) => {
    // Select first cell (0,0)
    const firstCell = page.locator('button.cell[data-row="0"][data-col="0"]');
    await firstCell.click();

    // Check that the wrapper has selected class
    await expect(page.locator('.cell-wrapper').first()).toHaveClass(/selected/);

    // Navigate to adjacent cell using ArrowRight
    await page.keyboard.press('ArrowRight');

    // Cell (0,1) wrapper should now be selected
    const secondCellWrapper = page.locator('.cell-wrapper').nth(1);
    await expect(secondCellWrapper).toHaveClass(/selected/);

    // Navigate down
    await page.keyboard.press('ArrowDown');

    // Cell (1,1) should now be selected
    page.locator('button.cell[data-row="1"][data-col="1"]');
    const targetWrapper = page.locator('.cell-wrapper').nth(10); // Row 1 * 9 + Col 1 = index 10
    await expect(targetWrapper).toHaveClass(/selected/);
  });

  test('should be accessible with keyboard navigation', async ({ page }) => {
    // Start with the first cell
    await page.locator('button.cell[data-row="0"][data-col="0"]').click();

    // Navigate through cells using arrow keys
    await page.keyboard.press('ArrowRight');
    await page.keyboard.press('ArrowDown');
    await page.keyboard.press('ArrowLeft');

    // We should now be at cell (1, 0)
    // Verify we can enter numbers
    await page.keyboard.press('7');

    // Find the currently selected cell
    const selectedCell = page.locator('button.cell[data-row="1"][data-col="0"]');

    // Check if it's a clue cell
    const isClue = await selectedCell.evaluate((el) => el.classList.contains('clue'));

    if (!isClue) {
      // Non-clue cell should show the entered number
      await expect(selectedCell).toContainText('7');
    }
  });

  test('should handle error states correctly', async ({ page }) => {
    // Find a clue cell (prefilled number)
    const clueCell = page.locator('button.cell.clue').first();
    await expect(clueCell).toBeVisible();

    const clueValue = await clueCell.textContent();
    if (!clueValue) {
      throw new Error('Clue cell has no value');
    }

    const clueNumber = clueValue.trim();
    const row = await clueCell.getAttribute('data-row');

    // Find an empty non-clue cell in the same row
    const cells = page.locator(`button.cell[data-row="${row}"]`);
    const cellCount = await cells.count();

    let targetCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        targetCell = cell;
        break;
      }
    }

    if (targetCell) {
      await targetCell.click();

      // Try to enter the same number as the clue (should cause error)
      await page.keyboard.press(clueNumber);

      // Cell should show error state
      await expect(targetCell).toHaveClass(/mistake/);
    }
  });

  test('should integrate candidate numbers component correctly', async ({ page }) => {
    // Find an empty non-clue cell
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let emptyCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        emptyCell = cell;
        break;
      }
    }

    if (!emptyCell) {
      throw new Error('No empty cell found');
    }

    await emptyCell.click();

    // The cell should not crash or show errors when selected
    await expect(emptyCell).toBeVisible();

    // The page should still be functional - verify we can enter numbers
    await page.keyboard.press('3');
    await expect(emptyCell).toContainText('3');
  });

  test('should add candidates using Shift+number without notes mode', async ({ page }) => {
    // Find an empty non-clue cell
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let emptyCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        emptyCell = cell;
        break;
      }
    }

    if (!emptyCell) {
      throw new Error('No empty cell found');
    }

    await emptyCell.click();

    // Enter candidate using Shift+1
    await page.keyboard.press('Shift+1');

    // Check for candidate number
    const candidate = emptyCell.locator('.candidate-number[data-testid="candidate-1"]');
    await expect(candidate).toBeVisible();

    // The cell should not be filled with "1" (should remain empty with candidate)
    const valueSpan = emptyCell.locator('span.value');
    await expect(valueSpan).not.toBeVisible();
  });

  test('should add candidates using Alt+number without notes mode', async ({ page }) => {
    // Find an empty non-clue cell
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let emptyCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        emptyCell = cell;
        break;
      }
    }

    if (!emptyCell) {
      throw new Error('No empty cell found');
    }

    await emptyCell.click();

    // Enter candidate using Alt+2
    await page.keyboard.press('Alt+2');

    // Check for candidate number
    const candidate = emptyCell.locator('.candidate-number[data-testid="candidate-2"]');
    await expect(candidate).toBeVisible();

    // Verify the cell isn't filled (should remain empty with candidate)
    const valueSpan = emptyCell.locator('span.value');
    await expect(valueSpan).not.toBeVisible();
  });

  test('should clear candidates using Shift+Delete', async ({ page }) => {
    // First, switch to notes mode (press 'n' key)
    await page.keyboard.press('n');

    // Find an empty non-clue cell
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let emptyCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        emptyCell = cell;
        break;
      }
    }

    if (!emptyCell) {
      throw new Error('No empty cell found');
    }

    await emptyCell.click();

    // Add multiple manual candidates using number keys (in notes mode)
    await page.keyboard.press('1');
    await page.keyboard.press('2');
    await page.keyboard.press('3');

    // Verify candidates were added
    const candidate1 = emptyCell.locator('.candidate-number[data-testid="candidate-1"]');
    const candidate2 = emptyCell.locator('.candidate-number[data-testid="candidate-2"]');
    const candidate3 = emptyCell.locator('.candidate-number[data-testid="candidate-3"]');

    await expect(candidate1).toBeVisible();
    await expect(candidate2).toBeVisible();
    await expect(candidate3).toBeVisible();

    // Switch back to fill mode
    await page.keyboard.press('n');

    // Clear all manual candidates using Delete key
    await page.keyboard.press('Delete');

    // Cell should be completely empty (no value, no candidates visible)
    const valueSpan = emptyCell.locator('span.value');
    await expect(valueSpan).not.toBeVisible();

    // Manual candidates should be cleared
    const manualCandidates = emptyCell.locator('.candidate-number.manual-candidate');
    await expect(manualCandidates).toHaveCount(0);
  });

  test('should toggle same candidate with Shift+number', async ({ page }) => {
    // Find an empty non-clue cell
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let emptyCell = null;
    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        emptyCell = cell;
        break;
      }
    }

    if (!emptyCell) {
      throw new Error('No empty cell found');
    }

    await emptyCell.click();

    // Add candidate 5 using Shift+5
    await page.keyboard.press('Shift+5');

    // Verify candidate 5 is visible
    const candidate5 = emptyCell.locator('.candidate-number[data-testid="candidate-5"]');
    await expect(candidate5).toBeVisible();

    // Press Shift+5 again to toggle it off
    await page.keyboard.press('Shift+5');

    // Candidate 5 should be gone
    await expect(candidate5).not.toBeVisible();
  });

  test('should automatically eliminate candidates when valid move is made (FR-012)', async ({ page }) => {
    // Step 1: Click "Fill Candidates" to populate all empty cells with candidates
    const fillCandidatesButton = page.locator('button:has-text("Fill Candidates")');
    await expect(fillCandidatesButton).toBeVisible();
    await fillCandidatesButton.click();

    // Wait for candidates to appear
    await page.locator('.candidate-number:not(.empty)').first().waitFor({ state: 'visible', timeout: 5000 });

    // Step 2: Find an empty cell with candidates
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let targetCell = null;
    let targetRow: string | null = null;
    let targetCol: string | null = null;

    for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        const candidates = cell.locator('.candidate-number:not(.empty)');
        const candidateCount = await candidates.count();

        if (candidateCount > 0) {
          targetCell = cell;
          targetRow = await cell.getAttribute('data-row');
          targetCol = await cell.getAttribute('data-col');
          break;
        }
      }
    }

    if (!targetCell || !targetRow || !targetCol) {
      throw new Error('No cell with candidates found');
    }

    await targetCell.click();

    // Step 3: Get a valid candidate value
    const candidatesInTarget = targetCell.locator('.candidate-number:not(.empty)');
    const firstCandidate = await candidatesInTarget.first().textContent();

    if (!firstCandidate) {
      throw new Error('No candidate value found');
    }

    // Step 4: Identify a cell in the same row with potential candidates
    const nextCol = String((Number(targetCol) + 1) % 9);
    const sameRowCell = page.locator(`button.cell[data-row="${targetRow}"][data-col="${nextCol}"]`);

    // Check if same row cell has the candidate before making the move
    const sameRowCandidatesBefore = sameRowCell.locator(`.candidate-number[data-testid="candidate-${firstCandidate}"]`);
    const hasCandidateInSameRow = await sameRowCandidatesBefore.isVisible().catch(() => false);

    // Step 5: Enter the candidate as a value in the target cell
    await page.keyboard.press(firstCandidate.trim());

    // Verify the cell now shows the value
    await expect(targetCell).toContainText(firstCandidate.trim());

    // Step 6: Verify automatic elimination - candidate should be removed from related cells
    if (hasCandidateInSameRow) {
      const sameRowCandidatesAfter = sameRowCell.locator(`.candidate-number[data-testid="candidate-${firstCandidate}"]`);
      // The candidate should have been eliminated from the same-row cell
      await expect(sameRowCandidatesAfter).not.toBeVisible();
    }
  });

  test('should restore eliminated candidates on undo (FR-012 + FR-022)', async ({ page }) => {
    // Step 1: Fill candidates
    const fillCandidatesButton = page.locator('button:has-text("Fill Candidates")');
    await expect(fillCandidatesButton).toBeVisible();
    await fillCandidatesButton.click();

    // Wait for candidates to appear
    await page.locator('.candidate-number:not(.empty)').first().waitFor({ state: 'visible', timeout: 5000 });

    // Step 2: Find an empty cell with candidates and a related cell that will have candidates eliminated
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let targetCell = null;
    let targetRow: string | null = null;
    let targetCol: string | null = null;
    let relatedCell = null;
    let candidateValue: string | null = null;

    // Search for a suitable scenario
    outerLoop: for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        const candidates = cell.locator('.candidate-number:not(.empty)');
        const candidateCount = await candidates.count();

        if (candidateCount > 0) {
          const row = await cell.getAttribute('data-row');
          const col = await cell.getAttribute('data-col');

          // Get all candidates for this cell
          for (let j = 0; j < candidateCount; j++) {
            const candidate = await candidates.nth(j).textContent();
            if (!candidate) continue;

            // Check all cells in the same row for this candidate
            for (let c = 0; c < 9; c++) {
              if (c === Number(col)) continue; // Skip the target cell itself

              const relatedCellCandidate = page.locator(
                `button.cell[data-row="${row}"][data-col="${c}"] .candidate-number[data-testid="candidate-${candidate.trim()}"]`
              );

              if (await relatedCellCandidate.isVisible().catch(() => false)) {
                // Found a suitable scenario!
                targetCell = cell;
                targetRow = row;
                targetCol = col;
                relatedCell = page.locator(`button.cell[data-row="${row}"][data-col="${c}"]`);
                candidateValue = candidate.trim();
                break outerLoop;
              }
            }
          }
        }
      }
    }

    if (!targetCell || !targetRow || !targetCol || !relatedCell || !candidateValue) {
      throw new Error('No suitable cell combination found for testing candidate elimination');
    }

    await targetCell.click();

    // Step 3: Verify the related cell has the candidate before making the move
    const relatedCandidateBefore = relatedCell.locator(`.candidate-number[data-testid="candidate-${candidateValue}"]`);
    await expect(relatedCandidateBefore).toBeVisible();

    // Step 4: Enter the candidate as a value in the target cell
    await page.keyboard.press(candidateValue);

    // Verify the cell now shows the value
    await expect(targetCell).toContainText(candidateValue);

    // Step 5: Verify automatic elimination - candidate should be removed from related cells
    await expect(relatedCandidateBefore).not.toBeVisible();

    // Step 6: Click the Undo button
    const undoButton = page.locator('button:has-text("Undo")');
    await expect(undoButton).toBeEnabled();
    await undoButton.click();

    // Step 7: Verify the cell no longer has the value
    const valueSpan = targetCell.locator('span.value');
    await expect(valueSpan).not.toBeVisible();

    // Step 8: Verify the candidate is restored in the related cell
    await expect(relatedCandidateBefore).toBeVisible();
  });

  test('should re-apply candidate elimination on redo (FR-012 + FR-022)', async ({ page }) => {
    // Step 1: Fill candidates
    const fillCandidatesButton = page.locator('button:has-text("Fill Candidates")');
    await expect(fillCandidatesButton).toBeVisible();
    await fillCandidatesButton.click();

    // Wait for candidates to appear
    await page.locator('.candidate-number:not(.empty)').first().waitFor({ state: 'visible', timeout: 5000 });

    // Step 2: Find an empty cell with candidates and a related cell that will have candidates eliminated
    const cells = page.locator('button.cell');
    const cellCount = await cells.count();

    let targetCell = null;
    let targetRow: string | null = null;
    let targetCol: string | null = null;
    let relatedCell = null;
    let candidateValue: string | null = null;

    // Search for a suitable scenario
    outerLoop: for (let i = 0; i < cellCount; i++) {
      const cell = cells.nth(i);
      const hasClueClass = await cell.evaluate((el) => el.classList.contains('clue'));
      const hasValue = await cell.locator('span.value').count();

      if (!hasClueClass && hasValue === 0) {
        const candidates = cell.locator('.candidate-number:not(.empty)');
        const candidateCount = await candidates.count();

        if (candidateCount > 0) {
          const row = await cell.getAttribute('data-row');
          const col = await cell.getAttribute('data-col');

          // Get all candidates for this cell
          for (let j = 0; j < candidateCount; j++) {
            const candidate = await candidates.nth(j).textContent();
            if (!candidate) continue;

            // Check all cells in the same row for this candidate
            for (let c = 0; c < 9; c++) {
              if (c === Number(col)) continue; // Skip the target cell itself

              const relatedCellCandidate = page.locator(
                `button.cell[data-row="${row}"][data-col="${c}"] .candidate-number[data-testid="candidate-${candidate.trim()}"]`
              );

              if (await relatedCellCandidate.isVisible().catch(() => false)) {
                // Found a suitable scenario!
                targetCell = cell;
                targetRow = row;
                targetCol = col;
                relatedCell = page.locator(`button.cell[data-row="${row}"][data-col="${c}"]`);
                candidateValue = candidate.trim();
                break outerLoop;
              }
            }
          }
        }
      }
    }

    if (!targetCell || !targetRow || !targetCol || !relatedCell || !candidateValue) {
      throw new Error('No suitable cell combination found for testing candidate elimination');
    }

    await targetCell.click();

    // Step 3: Verify the related cell has the candidate before making the move
    const relatedCandidateBefore = relatedCell.locator(`.candidate-number[data-testid="candidate-${candidateValue}"]`);
    await expect(relatedCandidateBefore).toBeVisible();

    // Step 4: Enter the candidate as a value in the target cell
    await page.keyboard.press(candidateValue);

    // Verify the cell now shows the value
    await expect(targetCell).toContainText(candidateValue);

    // Step 5: Verify automatic elimination - candidate should be removed from related cells
    await expect(relatedCandidateBefore).not.toBeVisible();

    // Step 6: Click the Undo button
    const undoButton = page.locator('button:has-text("Undo")');
    await expect(undoButton).toBeEnabled();
    await undoButton.click();

    // Verify the undo worked
    const valueSpan = targetCell.locator('span.value');
    await expect(valueSpan).not.toBeVisible();
    await expect(relatedCandidateBefore).toBeVisible();

    // Step 7: Click the Redo button
    const redoButton = page.locator('button:has-text("Redo")');
    await expect(redoButton).toBeEnabled();
    await redoButton.click();

    // Step 8: Verify the cell shows the value again
    await expect(targetCell).toContainText(candidateValue);

    // Step 9: Verify the candidate is eliminated again from the related cell
    await expect(relatedCandidateBefore).not.toBeVisible();
  });
});
